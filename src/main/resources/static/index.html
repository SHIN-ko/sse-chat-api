<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SSE Chat Demo</title>
<style>
    :root { --gap: 12px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; margin: 24px auto; max-width: 880px; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
    label { font-weight: 600; display: block; margin-bottom: 6px; }
    textarea, input[type="text"] { width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 10px; }
    textarea { min-height: 80px; }
    .row { display: grid; gap: var(--gap); }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    .row.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
    .actions { display: flex; gap: var(--gap); flex-wrap: wrap; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #e5e7eb; background: white; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .status { font-size: 12px; opacity: .8; }
    pre#out { white-space: pre-wrap; border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; min-height: 180px; margin: 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; }
</style>

<h1>Streaming Chat (SSE) — Demo</h1>

<div class="card">
    <div class="row">
        <div>
            <label for="system">System</label>
            <textarea id="system" placeholder="시스템 프롬프트 (선택) 예: 너는 친절한 한국어 도우미야.">너는 친절한 한국어 도우미야.</textarea>
        </div>
        <div>
            <label for="user">User Prompt</label>
            <textarea id="user" placeholder="질문을 입력하세요">Compose 환경에서 모델을 실행하는 장점을 2줄로 말해줘</textarea>
        </div>
    </div>

    <div class="row cols-3" style="margin-top:var(--gap)">
        <div>
            <label>모드</label>
            <div class="mono small">
                <label><input type="radio" name="mode" value="sse-get" checked> SSE (GET /api/chat/stream)</label><br>
                <label><input type="radio" name="mode" value="sse-post"> SSE (POST /api/chat/stream)</label><br>
                <label><input type="radio" name="mode" value="once"> 비스트리밍 (POST /api/chat)</label>
            </div>
        </div>
        <div>
            <label>옵션</label>
            <div class="mono small">
                <label><input type="checkbox" id="autoscroll" checked> Auto-scroll</label><br>
                <label><input type="checkbox" id="appendNewline"> 줄바꿈 보정(문장 끝)</label>
            </div>
        </div>
        <div>
            <label>도구</label>
            <div class="actions">
                <button id="run">Run</button>
                <button id="stop" disabled>Stop</button>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <div class="actions" style="justify-content: space-between;">
        <div class="status mono small" id="status">idle</div>
        <div class="actions">
            <button id="copy">Copy</button>
            <button id="clear">Clear</button>
            <button id="download">Download</button>
        </div>
    </div>
    <pre id="out" class="mono"></pre>
    <div class="status mono small" id="stats"></div>
</div>

<script>
    (() => {
        const $ = (s) => document.querySelector(s);
        const systemEl = $('#system');
        const userEl = $('#user');
        const outEl = $('#out');
        const statusEl = $('#status');
        const statsEl = $('#stats');
        const runBtn = $('#run');
        const stopBtn = $('#stop');
        const copyBtn = $('#copy');
        const clearBtn = $('#clear');
        const downloadBtn = $('#download');
        const autoscrollEl = $('#autoscroll');
        const appendNewlineEl = $('#appendNewline');

        let es = null;               // EventSource 핸들
        let abortController = null;  // fetch POST 스트림 중단용
        let startedAt = 0;
        let chunkCount = 0;
        let charCount = 0;

        const setStatus = (s) => { statusEl.textContent = s; };
        const resetStats = () => { startedAt = Date.now(); chunkCount = 0; charCount = 0; statsTick(); };
        const statsTick = () => {
            const sec = Math.max(0.001, (Date.now() - startedAt) / 1000);
            statsEl.textContent = `chunks=${chunkCount} | chars=${charCount} | elapsed=${sec.toFixed(2)}s | cps≈${(charCount/sec).toFixed(1)}`;
        };
        const append = (text) => {
            outEl.textContent += text;
            charCount += text.length;
            if (autoscrollEl.checked) outEl.scrollTop = outEl.scrollHeight;
            statsTick();
        };
        const done = () => {
            setStatus('done');
            runBtn.disabled = false; stopBtn.disabled = true;
            if (appendNewlineEl.checked) append('\n');
        };
        const onError = (err) => {
            setStatus(`error: ${String(err)}`);
            runBtn.disabled = false; stopBtn.disabled = true;
        };

        clearBtn.onclick = () => { outEl.textContent = ''; setStatus('idle'); statsEl.textContent=''; };
        copyBtn.onclick = async () => {
            try { await navigator.clipboard.writeText(outEl.textContent); setStatus('copied'); }
            catch (e) { setStatus('copy failed'); }
        };
        downloadBtn.onclick = () => {
            const blob = new Blob([outEl.textContent], {type: 'text/plain;charset=utf-8'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `chat-${new Date().toISOString().replace(/[:.]/g,'')}.txt`;
            a.click();
            URL.revokeObjectURL(a.href);
        };

        stopBtn.onclick = () => {
            if (es) { es.close(); es = null; }
            if (abortController) { abortController.abort(); abortController = null; }
            done();
        };

        runBtn.onclick = async () => {
            const system = systemEl.value.trim();
            const userPrompt = userEl.value.trim();
            if (!userPrompt) { alert('User Prompt를 입력하세요.'); return; }

            outEl.textContent = '';
            setStatus('connecting...');
            runBtn.disabled = true; stopBtn.disabled = false;
            resetStats();

            const mode = document.querySelector('input[name="mode"]:checked').value;

            try {
                if (mode === 'sse-get') {
                    // GET SSE: /api/chat/stream?system=&userPrompt=
                    const qs = new URLSearchParams({ userPrompt });
                    if (system) qs.set('system', system);
                    es = new EventSource(`/api/chat/stream?` + qs.toString());
                    es.onmessage = (e) => {
                        chunkCount++;
                        append(e.data || '');
                    };
                    es.addEventListener('done', () => { es.close(); es = null; done(); });
                    es.onerror = (e) => { es?.close(); es=null; onError('SSE error'); };
                    setStatus('streaming (SSE GET)');
                } else if (mode === 'sse-post') {
                    // POST SSE: fetch ReadableStream
                    abortController = new AbortController();
                    const resp = await fetch('/api/chat/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ system, userPrompt }),
                        signal: abortController.signal
                    });
                    if (!resp.ok || !resp.body) { throw new Error('HTTP ' + resp.status); }
                    setStatus('streaming (SSE POST)');
                    const reader = resp.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    while (true) {
                        const { done: d, value } = await reader.read();
                        if (d) break;
                        buffer += decoder.decode(value, { stream: true });
                        const events = buffer.split('\n\n'); // SSE event boundary
                        buffer = events.pop(); // keep remainder
                        for (const evt of events) {
                            const lines = evt.split('\n');
                            const dataLine = lines.find(l => l.startsWith('data: '));
                            const eventLine = lines.find(l => l.startsWith('event: '));
                            if (eventLine && eventLine.replace('event:','').trim() === 'done') {
                                done(); return;
                            }
                            if (!dataLine) continue;
                            const payload = dataLine.slice(6);
                            chunkCount++;
                            append(payload);
                        }
                    }
                    done();
                } else {
                    // once: POST /api/chat (non-stream)
                    const resp = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ system, userPrompt })
                    });
                    if (!resp.ok) throw new Error('HTTP ' + resp.status);
                    const json = await resp.json();
                    append(json.content ?? '');
                    done();
                }
            } catch (e) {
                onError(e);
            }
        };
    })();
</script>
